----------------------------------------------------------------------
h1. Configuration

h3. Buts

* Configurer git pour qu'il soit prêt à être utilisé.

h2. Configurer son nom et son email

p. Si vous n'avez jamais utilisé git avant, vous allez devoir faire quelques
paramétrages d'abord.
Lancer les commandes suivantes pour que git connaisse votre nom et votre email.
Si vous avez déjà configuré git, vous pouvez passez plus bas à la partie sur
les fins de ligne.

execute:
git config --global user.name "Votre nom"
git config --global user.email "votre_email@votredomaine.com"

h2. Paramétrer les préférences du type de fin de lignes

Aussi, pour les utilisateurs Unix/Mac:

execute:
git config --global core.autocrlf input
git config --global core.safecrlf true

Et pour les utilisateurs Windows:

execute:
git config --global core.autocrlf true
git config --global core.safecrlf true

----------------------------------------------------------------------
h1. Configuration supplémentaire

h3. Buts

* Avoir le matériel pour le tutoriel paramétré et prêt à être utilisé.

h2. Obtenir le paquet pour le tutoriel.

p. Télécharger le paquet pour le tutoriel depuis:

* L'URL "http://gitimmersion.com/git_tutorial.zip":http://gitimmersion.com/git_tutorial.zip

h2. Dézipper le tutoriel

p. Le paquet pour le tutoriel doit contenir un répertoire principal "git_tutorial"
avec trois sous-répertoires:

* html -- Ces fichiers html.  Lancer votre navigateur depuis html/index.html
* work -- Un répertoire de travail vide.  Créer votre dépôt dedans.
* repos -- Dépôts Git préparés pour vous permettre d'avancer dans le tutoriel
en partant de n'importe quelle étape.  Si vous êtes bloqué, copier juste le
dépôt souhaité dans votre répertoire de travail.

----------------------------------------------------------------------
h1. Créer un projet

h3. Buts

* Apprendre à créer un dépôt git à partir de rien.

h2. Créer un programme "Bonjour, Monde"

p. En commençant dans le répertoire de travail vide, créer un répertoire vide
nommé "bonjour", ensuite créer un fichier nommé @bonjour.rb@ avec le contenu
ci-dessous.

Execute:
mkdir bonjour
cd bonjour

File: bonjour.rb
puts "Bonjour, Monde"
EOF

h2. Créer le dépôt

p. Vous avez maintenant un répertoire avec un fichier unique. Pour créer une
dépôt git depuis ce répertoire, lancer la commande git init.

Execute:
git init
=init
+git config user.name "Jim Weirich"
+git config user.email "jim (at) edgecase.com"

Output:
=init
EOF

h2. Ajouter le programme au dépôt

Maintenant ajoutons le fichier du programme "Bonjour, Monde" au dépôt.

Execute:
git add bonjour.rb
=add
git commit -m "Mon premier commit"
=commit

p. Vous devriez voir ...

Output:
=add
=commit
EOF

----------------------------------------------------------------------
h1. Vérifier le status

h3. Buts

* Apprendre comment vérifier le statut du dépôt

h2. Vérifier le status du dépôt

p. Utiliser la commande @git status@ pour vérifier le statut de votre dépôt.


Execute:
git status
=status

p. Vous devriez voir

Output:
=status
EOF

p. La commande status renvoie qu'il n'y a rien à commiter. Cela
signifie que le dépôt a l'état complet du répertoire de travail.
Il n'y a pas de changements signalés comme à enregistrer.

p. Nous allons utiliser la commande @git status@ pour continuer à suivre
l'état entre le dépôt et le répertoire de travail.

----------------------------------------------------------------------
h1. Effectuer des changements

h3. Buts

* Apprendre comment suivre l'état du répertoire de travail

h2. Changer le programme "Bonjour, Monde".

p. Il est temps de changer notre programme bonjour pour lui passer un argument
depuis la ligne de commande. Changer le fichier pour qu'il soit:

File: bonjour.rb
puts "Bonjour, #{ARGV.first}!"
EOF

h2. Vérifier le status

p. Maintenant vérifier le statut de du répertoire de travail.

Execute:
!git status
=status

p. Vous devriez voir ...

Output:
=status
EOF

p. La première chose à constater est que git sait que le fichier @bonjour.rb@
a été modifié, mais que git n'a pas encore averti de ces changements.

p. Noter également que le message de status vous guide sur ce que vous alles
devoir faire par la suite. Si vous voulez ajouter ces changements au répertoire,
alors utiliser la commande @git add@. Dans le cas contraire, la commande
@git checkout@ peut être utilisé pour annuler les changements.

h2. Et après

p. Déclarons les changements.

----------------------------------------------------------------------
h1. Déclarer les changements

h3. Buts

* Apprendre à déclarer les changements pour les commits à venir

h2. Ajouter les changements

p. Maintenant indiquer à git de prendre en compte les changements déclarés. Vérifier le status

Execute:
git add bonjour.rb
=add
git status
=status

p. Vous devriez voir ...

Output:
=add
=status
EOF

p. Le changement sur le fichier @bonjour.rb@ a été déclaré. Cela signifie
que git est informé du changement, mais le changement n'a pas pas encore
eté enregistré de manière _permanente_ dans le dépôt. La prochaine opération
de commit inclura les changements qui ont été déclarés.

p. Si vous décidez que vous _ne_ voulez pas commiter ce changement après tout,
la commande de status vous rappelle que la commande @git reset@ peut être
utilisée pour annuler la déclaration de ce changement.

----------------------------------------------------------------------
h1. Déclarer et commiter

p. Une étape de déclaration des fichiers séparée depuis git est en rapport
avec la philosophie de ne pas être bloqué tant que vous n'avez pas besoin
d'utiliser un gestionnaire de version.
Vous pouvez continuer à faire des changements dans votre répertoire de travail
et ensuite, lorsque vous devez commencer à utiliser le gestion de version, git
vous permet d'enregistrer vos changements dans de petits commits qui
enregistrent exactement ce que vous avez fait.

p. Par exemple, supposons que vous éditiez trois fichiers (@a.rb@, @b.rb@, et
@c.rb@). Maintenant vous voulez commiter tous les changements, mais vous voulez
que les changements dans @a.rb@ et @b.rb@ soient dans un seul commit et que ceux
dans @c.rb@uuu sans rapport logique avec les deux premiers fichiers soient dans
un commit séparé.

p. Vous pourriez faire:

pre(instructions).
git add a.rb
git add b.rb
git commit -m "Changements pour a et b"

pre(instructions).
git add c.rb
git commit -m "Changement sans rapport sur c"

p. En séparant la déclaration du commit, vous avez la possibilité de
choisir précisément et facilement ce que vous ajoutez à chaque commit.

----------------------------------------------------------------------
h1. Commiter les changements

h3. Buts

* Apprendre à commiter les changements au dépôt

h2. Commiter le changement

p. Ok, assez avec la déclaration.  Maintenant commitons ce que nous avons
déclaré dans le répertoire.

p. Quand vous avez utilisé @git commit@ précédemment pour commiter la version
initiale du fichier @bonjour.rb@ dans le dépôt, vous avez inclus l'indicateur @-m@
qui renvoie un commentaire dans la légende de la commande. La commande de commit va
vous permettre d'éditer un commentaire de manière interactive pour le commit.
Essayons maintenant.

p. Si vous oubliez l'indicateur @-m@ depuis la ligne de commande, git va vous
ouvrir l'éditeur de texte de votre choix. Cet éditeur est choisi en s'appuyant
sur la liste suivante (avec par ordre de priorité):

* la variable d'environnement GIT_EDITOR
* le paramètre de configuration core.editor
* la variable d'environnement VISUAL
* la variable d'environnement EDITOR

p. J'ai la variable EDITOR définie à @emacsclient@.

p. Ainsi commitons maintenant et vérifions le status.

Execute:
-git commit
+git commit -m "Utilisation de ARGV"

p. Vous devriez voir la chose suivante dans votre éditeur:

Output:
|
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   bonjour.rb
#
EOF

p. Sur la première ligne, entrer le commentaire: "Utilisation de ARGV". Sauver le
fichier et sortir de l'éditeur. Vous devriez voir ...

Output:
git commit
Waiting for Emacs...
[master 569aa96] Utilisation de ARGV
 1 files changed, 1 insertions(+), 1 deletions(-)
EOF

p. La ligne "Waiting for Emacs..." vient du programme @emacsclient@ qui envoie
le fichier au programme dmacs et attend que le fichier soit fermé. Le reste de
la sortie est constitué des messages standards pour un commmit.

h2. Vérifier le status

p. Finalement essayons de vérifier le status encore.

Execute:
!git status
=status

Vous devriez voir ...

Output:
=status
EOF

p. Le répertoire de travail est propre et prêt pour que vous continuiez.

----------------------------------------------------------------------
h1. Changements, pas fichiers

h3. Buts

* Apprendre que git fonctionne avec les changements, pas avec les fichiers.

p. La plupart des logiciels de gestion de version travaillent avec des
fichiers. Vous ajoutez un fichier à la source versionnée et le sytème suivra
les changements que vous effectuez dessus à partir de ce moment.

p. Git se concentre sur les changements dans un fichier plutôt que sur le
fichier en lui même.
Quand vous faites @git add file@, vous ne dites pas à git d'ajouter le fichier
au dépôt. Vous dites plutôt que git devrait prendre en compte la situation de
ce fichier pour qu'il soit commité plus tard.

p. Nous allons chercher à vous faire explorer cette différence dans cette
partie.

h2. Premier changement: autoriser un nom de fichier par défaut

p. Changer le programme "Bonjour, Monde" pour avoir une valeur par défaut si un
argument est passé en ligne en commande s'il n'est pas fourni.

File: bonjour.rb
nom = ARGV.first || "Monde"

puts "Bonjour, #{nom}!"
EOF

h2. Rajouter ce changement

p. Maintenant ajouter ce changement dans la déclaration des fichiers de git.

Execute:
git add bonjour.rb

h2. Deuxième changement: ajouter une commentaire

p. Maintenant ajouter un commentaire au programme "Bonjour, Monde".

File: bonjour.rb
# L'argument par défaut est Monde
nom = ARGV.first || "Monde"

puts "Bonjour, #{nom}!"
EOF

h2. Vérifier le status courant

Execute:
!git status
=status

p. Vous devriez voir ...

Output:
=status
EOF

p. Remarquer comment @bonjour.rb@ est listé deux fois dans le status. Le premier
changement (ajouter une valeur par défaut) est déclaré et est prêt à être commité.
Le second changement (ajouter un commentaire) n'est pas déclaré. Si vous deviez
commiter dès maintenant, le commentaire ne serait pas sauvé dans le dépôt.

p. Maintenant essayons cela.

h2. Commiter

p. Commiter le changement déclaré (la valeur par défaut), et ensuite revérifions le status.

Execute:
git commit -m "Ajouter une valeur par défaut"
=commit
git status
=status2

p. Vous devriez voir ...

Output:
=commit
=status2
EOF

p. La commande de status vous dit que @bonjour.rb@ a des changements non enregistrés,
mais n'est plus dans la liste des fichiers déclarés.

h2. Ajouter le second changement

p. Maintenant ajouter le second changement à la liste des fichiers déclarés,
ensuite lancer git status.

Execute:
git add .
!git status
=status3

p(note). *Note:* Nous utilisons le répertoire courant ('.') comme le
fichier à ajouter. C'est vraiment un raccourci pratique pour ajouter tous
les changements aux fichiers dans le répertoire courant et en dessous. Mais
comme il ajoute tout, c'est _vraiment_ une bonne idée de vérifier le status
avant de faire un <tt>add .</tt>, juste pour s'assurer que vous n'ajoutez aucun
fichier qui ne soit pas désiré.

p(note). Je voulais que voyiez l'astuce "add .", mais nous allons continuer
à ajouter explicitement les fichiers dans le reste du tutoriel juste pour
être sûr.

p. Vous devriez voir ...

Output:
=status3
EOF

p. Maintenant le second changement a été déclaré et est prêt à être commité.

h2. Commiter le second changement

Execute:
git commit -m "Ajout d'un commentaire"

----------------------------------------------------------------------
h1. Historique

h3. Buts

* Apprendre comment voir l'historique du projet.

p. Avoir une liste des changements qui ont été effectués est le rôle de la
commande @git log@.

Execute:
git log
=log

p. Vous devriez voir ...

Output:
=log
EOF

p. Voici la liste des quatre commits que nous avons fait dans le dépôt
jusqu'à maintenant.

h2. Historique avec les entrées affichées sur une ligne

p. Vous avez une grande possibilité de contrôle sur ce que la commande @log@
renvoie. J'aime bien le formatage sur une ligne:

Execute:
git log --pretty=oneline
=oneline

p. Vous devriez voir ...

Output:
=oneline
EOF

h2. Contrôler quelles entrées sont affichées

p. Il y a beaucoup d'options pour sélectionner quelles entrées sont
affichées dans le log. Jouez avec les commandes suivantes:

pre(instructions).
git log --pretty=oneline --max-count=2
git log --pretty=oneline --since='5 minutes ago'
git log --pretty=oneline --until='5 minutes ago'
git log --pretty=oneline --author=<votre nom>
git log --pretty=oneline --all

p. Voir man git-log pour tous les détails.

h2. Devenir imaginatif

p. Voici ce que j'utilise pour vérifier les changements faits au cours de la
dernière semaine. J'ajouterai @--author=jim@ si je veux seulement les changements
que j'ai fait.

pre(instructions).
git log --all --pretty=format:"%h %cd %s (%an)" --since='7 days ago'

h2. Le formatage de fichier de log ultime

p. Au fil du temps, j'ai décidé que j'aimais le formatage de log suivant
pour la plupart de mon travail.

Execute:
git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short
=ultimate

Cela ressemble à:

Output:
=ultimate
EOF

p. Regardons cette ligne dans le détail:

* @--pretty="..."@ définit le format de sortie.
* @%h@ est la hash abrégé du commit
* @%d@ est le type de décoration sur ce commit (comme les branches ou les tags)
* @%ad@ est la date de l'auteur
* @%s@ est le commentaire
* @%an@ est le nom de l'auteur
* @--graph@ informe git d'afficher l'arbre de commit dans un rendu de type graphe ASCII
* @--date=short@ garde le format de la date joli et court

p. C'est beaucoup à taper chaque fois que vous voulez voir le log.
Heuseusement nous apprendrons à utiliser les alias git dans la prochaine partie.

h2. Autres outils

p. Les deux <code>gitx</code> (pour Macs) et <code>gitk</code> (chaque plateforme)
sont utiles pour exlorer l'historique des logs.

----------------------------------------------------------------------
h1. Alias

h3. Buts

* Apprendre comment paramétrer les alias et les raccourcis pour les commandes git

h2. Alias communs

p. +git status+, +git add+, +git commit+, et +git checkout+ sont ces
commandes habituelles dont il est utile d'avoir des abbréviations.

p. Ajouter ce qui suit dans le fichier .gitconfig dans votre répertoire $HOME.

file: .gitconfig
[alias]
  co = checkout
  ci = commit
  st = status
  br = branch
  hist = log --pretty=format:\"%h %ad | %s%d [%an]\" --graph --date=short
  type = cat-file -t
  dump = cat-file -p
EOF

p. Nous avons couverts checkout, commit et status. Et nous avons aussi
couvert la commande @log@ dans la précédente partie. Maintenant vous
pouvez taper @git co@ à la place de taper @git checkout@. De la même manière
@git st@ pour @git status@ et @git ci@ pour @git commit@. Et le meilleur de
tous, @git hist@ vous permettra d'éviter la très longue commande @log@.

p. Continuez et faites quelques essais pour essayer.

h2. Définir l'alias @hist@ dans votre fichier @.gitconfig@

p. Pour la plupart des cas, je continuerais à taper les commandes complètes
dans les instructions. La seule exception est que j'utiliserais l'alias @hist@
défini ci-dessus chaque fois que vous avez besoin de voir la sortie de log git.
Assurer vous d'avoir un alias @hist@ configuré dans votre fichier @.gitconfig@
avant de continuer le tutoriel suivant.

h2. @Type@ et @Dump@

p. Nous avons déjà ajouté quelques alias pour des commandes que nous n'avons
pas encore abordé. La commande @git branch@ va bientôt être abordée. et la
commande @git cat-file@ est utile pour explorer git, ce que nous verrons dans
un petit moment.

h2. Alias de la ligne de commande (optionnel)

p(note). *Note:* Cette section est pour les utilisateurs qui utilisent une ligne
de commande de type posix. Les utilisateurs Windows et ceux utilisant une
ligne de commande non-posix peuvent passer à la prochaine partie.

p. Si votre ligne de commande supporte les alias et les raccourcis, ensuite vous
pouvez utiliser des alias à ce niveau également. Voici ceux que j'utilise:

file: .profile
alias gs='git status '
alias ga='git add '
alias gb='git branch '
alias gc='git commit'
alias gd='git diff'
alias go='git checkout '
alias gk='gitk --all&'
alias gx='gitx --all'

alias got='git '
alias get='git '
EOF

p. L'abbréviation @go@ pour @git checkout@ est particulièrement jolie. Cela me
permet de taper:

pre(instructions). go <branch>

p. Pour récupérer une branche particulière.

p. Et oui, je tape par erreur @git@ comme @get@ ou @got@ suffisamment souvent
pour créer l'alias pour eux.

----------------------------------------------------------------------
h1. Obtenir de vieille versions

h3. Buts

* Apprendre comment récupérer n'importe quelle état du dépôt dans le répertoire
de travail.

p. Retourner dans l'historique est très facile. La commande checkout va copier
n'importe quel état depuis le dépôt vers le répertoire de travail.

h2. Obtenir les hashs pour les précédentes versions

Execute:
git hist
=log

p(note). *Note:* Vous vous rappelez avoir défini @hist@ dans votre fichier
@.gitconfig@, n'est ce pas? Si ce n'est pas le cas, revoyez le tutoriel
sur les alias.

Output:
=log
EOF

p. Examiner la sortie du log et trouver le hash pour le premier commit. Cela
doit être la dernière ligne de la sortie de @git hist@. Utiliser le code hash
(les 7 premiers caractères sont suffisants) dans la commande ci-dessous. Ensuite,
vérifier le contenu du fichier bonjour.rb.

Set: hash=hash_for("Mon premier commit")
Execute:
git checkout <hash>
=checkout
cat bonjour.rb
=cat

p(note). *Note:* Les commandes données ici sont des commandes Unix et
fonctionnent à la fois sous Mac et Linux. Malheureusement, les utilisateurs Windows
devront traduire pour leur ligne de commande propre (DOS).

p(note). *Note:* De nombreuses commandes dépendent des valeurs de hash
dans le dépôt. Comme vos valeurs de hash vont changer des miennes, chaque fois que
vous voyez quelque chose comme &lt;hash&gt; ou &lt;treehash&gt; dans la commande,
remplacer la valeur par votre propre valeur de dépôt.

p. Vous devriez voir ...

Output:
=checkout
=cat
EOF

p. La sortie de la commande @checkout@ explique la situation de manière assez
claire. Les vieilles versions de git vont se plaindre de ne pas être sur une
branche locale. Dans tous les cas, ne vous en inquiétez pas maintenant.

p. Noter que les contenus du fichier bonjour.rb sont les contenus originaux.

h2. Retourner la dernière version de la branche master

Execute:
git checkout master
=checkout2
cat bonjour.rb
=cat2

p. Vous devriez voir ...

Output:
=checkout2
=cat2
EOF

p. 'master' est le nom de la branche par défaut. En faisant un "checkout"
sur une branche, vous avez la dernière version de cette branche.

----------------------------------------------------------------------
h1. Tagger des versions

h3. Buts

* Apprendre comment tagger des commits avec des noms pour des références futures

p. Appelons la version courante du programme bonjour version 1 (v1).

h2. Tagger la version 1

Execute:
git tag v1
=tag

p. Maintenant vous pouvez vous référer à la version courante du programme comme v1.

h2. Tagger des versions précédentes

p. Taggons immédiatement la première version précédente à la version courante sous
le nom v1-beta.  D'abord, nous devons revenir à la version précédente. Plutôt que
d'utiliser le hash, nous allons utilise la notation @^@ pour indiquer "le parent
de v1".

p(note). Si la notation @v1@^ vous cause un problème, vous pouvez aussi essayer
@v1~1@, qui référencera la même version. Cette notation signifie le "premier
ancêtre de v1".

Execute:
git checkout v1^
=checkout
cat bonjour.rb
=cat

Output:
=checkout
=cat
EOF

p. Voir que c'est la version avec la valeur par défaut _avant_ que nous ajoutions
le commentaire. Faisons cette v1-beta.

Execute:
git tag v1-beta

h2. Récupérer par nom de tag

p. Maintenant essayons de passer d'une version taggée à l'autre et inversement.

Execute:
git checkout v1
=cov1
git checkout v1-beta
=cov1beta

Output:
=cov1
=cov1beta
EOF

h2. Voir les tags en utilisant la commande @tag@

p. Vous pouvez voir quels tags sont disponibles en utilisant la commande @git tag@.

Execute:
git tag
=tag2

Output:
=tag2
EOF

h2. Voir les tags dans les logs

p. Vous pouvez aussi vérifier les tags dans le log.

Execute:
git hist master --all
=hist

Output:
=hist
EOF

p. Vous pouvez voir les deux tags (@v1@ et @v1-beta@) listés dans la sortie
de log, avec à côté le nom de la branche (@master@). Aussi, @HEAD@ vous
montre le commit qui est actuellement utilisé (qui est le @v1-beta@ pour
le moment).

----------------------------------------------------------------------
h1. Annuler les changements locaux (avant les déclarations)

h3. Buts

* Apprendre comment revenir sur les changements dans votre répertoire de travail

h2. Repasser sur la branche master

p. S'assurer que vous êtes sur le dernier commit dans master avant de continuer.

Execute:
git checkout master

h2. Changer bonjour.rb

p. Quelquefois, vous avez modifié un fichier dans votre répertoire de travail local
et vous souhaitez simplement revenir à l'état de ce qui a été déjà commité. La
commande checkout va gérer cela.

Changer bonjour.rb pour avoir un mauvais commentaire.

File: bonjour.rb
# Ceci est un mauvais commentaire. Nous voulons l'annuler.
nom = ARGV.first || "Monde"

puts "Bonjour, #{nom}!"
EOF

h2. Vérifier le status

p. En premier, vérifier le status du répertoire de travail.

Execute:
!git status
=status

Output:
=status
EOF

p. Nous voyons que le fichier @bonjour.rb@ a été modifié mais n'a pas encore été déclaré.

h2. Annuler les changements dans le répertoire de travail

p. Utiliser la commande @checkout@ pour récupérer la version du fichier @bonjour.rb@ issue
du dépôt.

Execute:
git checkout bonjour.rb
=checkout
!git status
=status2
cat bonjour.rb
=cat

Output:
=checkout
=status2
=cat
EOF

p. La commande status nous montre qu'il n'y a plus de changements indiqués
dans le répertoire de travail. Et le "mauvais commentaire" n'est plus dans
le contenu du fichier.

----------------------------------------------------------------------
h1. Annuler les déclarations de fichiers changés (avant de commiter)

h3. Buts

* Apprendre comment annuler des changements qui ont déjà été déclarés

h2. Changer le fichier et déclarer le changement

p. Modifier le fichier @bonjour.rb@ pour avoir un mauvais commentaire

File: bonjour.rb
# C'est un commentaire non désiré mais déjà déclaré
nom = ARGV.first || "Monde"

puts "Bonjour, #{nom}!"
EOF

p. Et maintenant continuer et déclarer le fichier.

Execute:
git add bonjour.rb

h2. Vérifier le status

p. Vérifier le status de votre changement non désiré.

Execute:
git status
=status

Output:
=status
EOF

p. La sortie du status montre que le changement a été déclaré et qu'il
est prêt à être commité.

h2. Réinitialiser la liste des fichiers déclarés

p. Heureusement la ligne de status nous dit exactement comment faire pour
annuler la déclaration du changement.

Execute:
git reset HEAD bonjour.rb
=reset

Output:
=reset
EOF

p. La commande @reset@ réinitialise la liste des fichiers déclarés à celle
qui est dans HEAD. Cela nettoye la liste des fichiers déclarés du changement
que nous venions juste de déclarer.

p. La commande @reset@ (par défaut) ne change pas le répertoire de travail
courant. Ainsi le répertoire de travail a toujours le commentaire non souhaité.
Nous pouvons utiliser la commande @checkout@ de la précédente partie pour enlever
la changement non désiré du répertoire de travail.

h2. Mettre à jour à la version commitée

Execute:
git checkout bonjour.rb
git status
=status2

Output:
=status2
EOF

p. Et notre répertoire de travail est propre à nouveau.

----------------------------------------------------------------------
h1. Annuler les changements déjà commités

h3. Buts

* Apprendre comment annuler revenir sur les changements qui ont déjà
été commités sur le dépôt local.

h2. Annuler des commits

p. Parfois vous réalisez qu'un changement que vous avez déjà commité
n'était pas correct et vous souhaitez annuler ce commit. Il y a
plusieurs façons de gérer ce problème, et la manière dont nous allons faire
cela dans cette partie du tutoriel est toujours sûre.

p. Essentiellement nous allons annuler le commit en créant un nouveau commit qui
inverse les changements non voulus.

h2. Changer le fichier et le commiter.

p. Changer le fichier @bonjour.rb@ de la manière suivante.

File: bonjour.rb
# C'est un changement non voulu mais déjà commité
nom = ARGV.first || "Monde"

puts "Bonjour, #{nom}!"
EOF

Execute:
git add bonjour.rb
git commit -m "Oups, nous  ne voulions pas ce commit"

h2. Créer un commit de retour en arrière

p. Pour annuler un changement commité, nous avons besoin de générer un commit
qui annule les changements introduits par notre commit non voulu.

Execute:
-git revert HEAD
+git revert HEAD --no-edit
=revert

p. Cela va vous ouvrir votre éditeur de texte. Vous pouvez éditer le message
de commit par défaut ou le laisser tel quel. Sauver et fermer le fichier.
Vous devriez voir ...

Output:
=revert
EOF

p. Comme nous étions en train d'annuler le dernier commit que nous avions
fait, nous avons été capable d'utiliser @HEAD@ comme argument pour annuler.
Nous pouvons annuler n'importe quel commit de manière arbitraire plus ancien
dans l'historique en spécifiant simplement la valeur de son hash.

p(note). *Note:* Le @--no-edit@ dans la sortie peut être ignoré.
Il était nécessaire de générer la sortie sans ouvrir l'éditeur.

h2. Vérifier le log

p. Vérifier que le log montre à la fois les commits non désirés et ceux
de correction des commits non désirés dans notre répertoire.

Execute:
git hist
=hist

Output:
=hist
EOF

p. Cette technique fonctionnera avec n'importe quel commit (même si vous allez
peut être devoir résoudre des conflits). C'est sûr pour être utilisé même sur
les branches qui sont partagées sur des dépôts distants.

h2. Quoi de plus

p. Maintenant, allons regarder une technique qui peut être utilisée pour enlever
les commits les plus récents de l'historique du dépôt.

----------------------------------------------------------------------
h1. Enlever des commits d'une branche

h3. Buts

* Apprendre comment enlever les commits les plus récents d'une branche

p. La commande @revert@ de la section précédente est une commande puissante
qui nous laisse défaire les effets de d'importe quel commit dans le dépôt.
Cependant, à la fois le commit original et celui qui l'annule sont visibles
dans l'historique de la branche (en utilisant la commande @git log@).

p. Souvent, nous faisons un commit et réalisons immédiatement que nous avons
commis une erreur. Il pourrait être pratique d'avoir une commande de retour
en arrière qui nous permette de faire comme si le mauvais commit n'avait jamais
existé. Cette commande de retour en arrière devrait aussi pouvoir prévenir
que le mauvais commit apparaisse dans l'historique de la commande @git log@.
Ce serait comme si le mauvais commit n'avait jamais existé.

h2. La commande @reset@

p. Nous avons déjà vu la commande @reset@ et l'avons utilisé pour garder les
fichiers en attente consistants avec un commit donné (nous avons utilisé le
commit HEAD dans la précédente partie).

p. Quand nous donnons la référence d'un commit (comme un hash, une branche ou
nom de tag), la commande @reset@ va ...

# Réécrire la branche courante jusqu'au point du commit spécifié
# De manière optionnelle, réinitialiser la liste des fichiers en attente pour
correspondre au commit spécifié
# De manière optionnelle, réinitialiser le répertoire de travail pour
correspondre au commit spécifié

h2. Vérifions notre historique

p. Faisons une petite vérification de de notre historique de commit.

Execute:
git hist
=hist

Output:
=hist
EOF

p. Nous voyons que nous avons un commit "Oups" et un commit "Annuler Oups"
comme deux derniers commits fait dans cette branche. Maintenant enlevons-les
en utilisant reset.

h2. En premier, marquer cette branche

p. mais avant d'enlever les commits, marquons le dernier commit avec
un tag pour que nous puissions encore le retrouver.

Execute:
git tag oups

h2. Réinitialiser à Avant Oups

p. En regardant l'historique de log (au dessus), nous voyions que le commit
taggé 'v1' est le commit juste avant le mauvais commit. Commençons par
réinitialiser la branche à ce point. A présent que cette branche est taggé,
nous pouvons utiliser le nom du tag dans la commande reset (si elle ne
l'était pas, nous pourrions juste utiliser la valeur de hash).

Execute:
git reset --hard v1
=reset
git hist
=hist2

Output:
=reset
=hist2
EOF

p. Notre branche master branch pointe maintenant vers le commit v1 et le commit
Oups et le commit Annuler Oups nes ont plus dans la branche. Le paramètre
@--hard@ indique que le répertoire de travail devrait être mis à jour pour être
consistant avec le head de la nouvelle branche.

h2. Rien n'est jamais perdu

p. Mais qu'est il arrivé aux mauvais commits? En fait les commits sont
toujours dans le dépôt. D'ailleurs, nous pouvons toujours les référencer.
Rappelez vous qu'au début de cette partie, nous avons taggé le commit
d'annulation avec le tag "oups". Regardons _tous_ les commits.

Execute:
git hist --all
=hist3

Output:
=hist3
EOF

p. Ici nous voyons que les mauvais commits n'ont pas disparus. Ils sont
toujours dans le dépôt. C'est juste qu'ils ne sont plus listés dans la
branche master. Si nous ne les avions pas taggés, ils seraient toujours
dans le dépôt, mais il n'y aurait plus moyen de les référencer autrement
que par leur nom de hash. Les commits non référencés restent dans le dépôt
jusqu'à ce que le système lance l'utilitaire de nettoyage mémoire.

h2. Les dangers du reset

p. Les réinitialisations sur les branches locales sont généralement sûres.
N'importe quel accident peut être généralement récupéré en faisant un reset
avec le commit désiré.

p. Cependant, si la branche est partagée sur des répertoires distants, faire
un reset peut gêner les autres utilisateurs de la branche.

----------------------------------------------------------------------
h1. Enlever le tag oups

h3. Buts

* Enlever le tag oups (pour faire le ménage)

h2. Enlever le tag oups

p. Le tag oups a atteint son but. Enlevons-le et permettons aux commits
qu'il référence d'être nettoyé.

Execute:
git tag -d oups
=tag
git hist --all
=hist

Output:
=tag
=hist
EOF

p. Le tag oups n'est désormais plus listé dans le dépôt.

----------------------------------------------------------------------
h1. Amender les commits

h3. Buts

* Apprendre comment amender un commit existant

h2. Changer le programme puis commiter

p. Ajouter un commentaire de l'auteur au programme.

File: bonjour.rb
# L'argument par défaut est Monde
# Auteur: Jim Weirich
nom = ARGV.first || "Monde"

puts "Bonjour, #{nom}!"
EOF

Execute:
git add bonjour.rb
git commit -m "Ajouter un commentaire avec l'auteur"

h2. Ah, une erreur, il faudrait un email

p. Après avoir fait le commit, vous réalisez  que n'importe quel bon commentaire
devrait avoir un email inclus. Mettre à jour le programme bonjour pour inclure un
email.

File: bonjour.rb
# L'argument par défaut est Monde
# Auteur: Jim Weirich (jim@somewhere.com)
nom = ARGV.first || "Monde"

puts "Bonjour, #{nom}!"
EOF

h2. Amender le commit précédent

p. Nous ne voulons vraiment pas un commit séparé juste pour l'email.
Amendons le commit précédent pour inclure le changement d'email.

Execute:
git add bonjour.rb
=add
git commit --amend -m "Add an author/email comment"
=commit

Output:
=add
=commit
EOF


h2. Vérifier l'historique

Execute:
git hist
=hist

Output:
=hist
EOF

p. Nous pouvons voir que le commit original "auteur" est parti, et qu'il
est remplacé par le commit "auteur/email". Vous pouvez obtenir le même
effet en réinitialisant la branche d'un commit puis recommiter les
nouveaux changements.

----------------------------------------------------------------------
h1. Déplacer les fichiers

h3. Buts

* Apprendre comment bouger un fichier dans un dépôt.

h2. Bougerle fichier bonjour.rb dans un répertoire lib.

p. Nous allons maintenant construire la structure de notre petit
dépôt. Bougeons le programme dans un répertoire lib.

Execute:
mkdir lib
=mkdir
git mv bonjour.rb lib
=move
!git status
=status

Output:
=mkdir
=move
=status
EOF

p. En utilisant git pour effectuer le déplacement, nous informons git de 2 choses

# Que le fichier @bonjour.rb@ a été supprimé.
# Que le fichier @lib/bonjour.rb@ a été créé.

p. Ces deux informations ont immédiatement été ajoutées dans la liste des fichiers
en attente et sont prêtes à être commitées. La commande git status renvoie que le
fichier a été déplacé.

h2. Une autre manière de bouger des fichiers

p. Une des choses agréable de git est que vous pouvez oublier le contrôle des
sources jusqu'à ce que vous soyez prêt à commiter le code.
Que ce passerait-t-il si nous utilisons les commandes du système d'exploitation
pour bouger le fichier plutôt que la commande git?

p. La suite de commandes suivante équivaut à ce que nous venons de faire.
C'est un peu plus de travail mais le résultat est identique.

p(command). Nous aurions pu faire:

pre(instructions). mkdir lib
mv bonjour.rb lib
git add lib/bonjour.rb
git rm bonjour.rb

h2. Commiter le nouveau dossier

p. Commitons ce déplacement.

Execute:
git commit -m "Déplacement de bonjour.rb dans lib"

----------------------------------------------------------------------
h1. Plus de structuration

h3. Buts

* Ajouter un autre fichier à notre dépôt

h2. Maintenant ajoutons un fichier Rakefile

p. Ajoutons un fichier Rakefile à notre dépôt. Ce qui suit convient
parfaitement pour cela.

File: Rakefile
#!/usr/bin/ruby -wKU

task :default => :run

task :run do
  require './lib/bonjour'
end
EOF

p. Ajouter et commiter le changement.

Execute:
git add Rakefile
git commit -m "Ajout d'un Rakefile"

p. Vous devriez maintenant être capable d'utiliser rake pour lancer
votre programme bonjour.

Execute:
rake
=rake

Output:
=rake
EOF

----------------------------------------------------------------------
h1. Fonctionnement interne de Git: le répertoire .git

h3. Buts

* Apprendre la structure du répertoire @.git@

h2. Le répertoire @.git@

p. C'est le moment de faire une petite exploration. En premier, depuis la racine
de votre répertoire de projet...

Execute:
ls -C .git
=lsgit

Output:
=lsgit
EOF

p. C'est le répertoire magique où les "trucs" de git sont stockés.
Allons jeter un oeil dans le répertoire des objets.

h2. Le magasin d'objets

Execute:
ls -C .git/objects
=lsobjs

Output:
=lsobjs
EOF

p. Vous devriez voir un ensemble de répertoires avec des noms de 2 lettres. Les
noms des répertoires sont les deux premières lettres du hash sha1 de l'objet
stocké dans git.

h2. Approfondissement sur le magasin d'objets

Set: dir=`ls .git/objects | head -1`.strip
Execute:
ls -C .git/objects/<dir>
=lsobjs2

Output:
=lsobjs2
EOF

p. Regardez dans l'un des répertoires à deux lettres. Vous devriez voir
quelques fichiers avec des noms de 38 caractères. Ce sont les fichiers
qui contiennent les objets stockés dans git. Ces fichiers sont compressés
et encodés, ainsi regarder à leur contenu directement ne sera pas très utile,
mais nous allons jeter un oeil plus attentif d'ici peu.

h2. Le fichier config

Execute:
cat .git/config
=cat

Output:
=cat
EOF

p. C'est un fichier de configuration propre au projet. Les entrées ici
vont supplanter les entrées de configuration dans le fichier @.gitconfig@
de votre répertoire personnel(home), du moins pour ce projet.

h2. Branches et tags

Execute:
ls .git/refs
=refs
ls .git/refs/heads
=refhead
ls .git/refs/tags
=reftags
cat .git/refs/tags/v1
=refv1

Output:
=refhead
=refs
=reftags
=refv1
EOF

p. Vous devriez reconnaître les fichiers dans le sous-répertoire des tags.
Chaque fichier correspond à un tag que vous avez créé avec la commande @git tag@
un peu plus tôt. Son contenu est juste le hash du commit associé au tag.

p. Le répertoire heads est similaire, mais est utilisé par les branches plutôt
que les tags. Nous avons seulement une branche pour le moment, ainsi tout ce que
verrez dans ce répertoire est master.

h2. Le fichier HEAD

Execute:
cat .git/HEAD
=head

Output:
=head
EOF

p. Le fichier HEAD contient une référence à la branche courante. Cela
devrait être une référence à master pour le moment.

----------------------------------------------------------------------
h1. Fonctionnement interne de Git: travailler directement avec les objets Git

h3. Buts

* Explorer la structure du magasin d'objets
* Apprendre comment utiliser les hashs SHA1 pour trouver le contenu dans
le dépôt

p. Maintenant utilisons quelques outils pour analyser directement les objets git.

h2. Trouver le dernier commit

Execute:
git hist --max-count=1
=log

p. Cela devrait montrer le dernier commit fait dans le dépôt. Le hash
SHA1 sur votre système est probablement différent de celui qui est chez nous,
mais vous devriez voir quelque chose de ce type.

Output:
=log
EOF

h2. Extraire les infos du dernier commit

Utiliser le hash SHA1 depuis le commit listé ci-dessus ...

Set: hash=hash_for("Ajout d'un Rakefile")
Execute:
git cat-file -t <hash>
=type
git cat-file -p <hash>
=dump

Voici notre sortie ...

Output:
=type
=dump
EOF

p(note). *NOTE:* Si vous avez défini les alias 'type' et 'dump' aliases dans
la partie sur les alias, alors vous pouvez taper @git type@ et @git dump@ plutôt
que la ligne de commande plus longue cat-file (dont je ne me souviens jamais).

p. Ceci est le dump de l'objet commité qui est le head de la branche master.
Il ressemble beaucoup à l'objet commit de la présentation précédente.

h2. Trouver l'arbre

p. Nous pouvons faire un dump de l'arborescence du répertoire référencé dans le
commit. Cela devrait être une description des fichier (du niveau supérieur)
dans notre projet ( pour ce commit). Utiliser le hash SHA1 depuis la ligne de
"l'arbre" listée ci-dessus.

Set: treehash=hash_in(var['hash'], 'tree')
Execute:
git cat-file -p <treehash>
=treedump

p. Voilà à quoi ressemble mon arbre...

Output:
=treedump
EOF

p. Super, je vois le Rakefile et le répertoire lib.

h2. Faire un dump du répertoire lib

Set: libhash=hash_in(var['treehash'], 'lib')
Execute:
git cat-file -p <libhash>
=libdump

Output:
=libdump
EOF

p. Il y a le fichier @bonjour.rb@.

h2. Faire un dump du fichier @bonjour.rb@

Set: rbhash=hash_in(var['libhash'], 'bonjour')
Execute:
git cat-file -p <rbhash>
=rbdump

Output:
=rbdump
EOF

p. Maintenant vous savez. Nous avons fait des dumps d'objets commit, d'objets arbre
et d'objets blob directement depuis le dépôt git. C'est tout ce qu'il y a dedans,
des blobs, des arbres et des commits.

h2. Explorer par vous-même

p. Explorer le dépôt git manuellement par vous-même. Regarder si vous pouvez
trouver le fichier original bonjour.rb du premier commit en suivant en manuel
les références du hash SHA1 en partant du dernier commit.

----------------------------------------------------------------------
h1. Créer une branche

h3. Buts

* Apprendre comment créer une branche locale dans un dépôt

p. Il est l'heure de faire une réécriture importante de la fonctionnalité
bonjour monde. Comme cela risque de prendre du temps, vous voudrez mettre ces
changements dans une branche séparée pour les isoler de ceux dans master.

h2. Créer une branche

p. Appelons notre nouvelle branche 'saluer'.

Execute:
git checkout -b saluer
!git status

p(note). *NOTE:* @git checkout -b <nombranche>@ est une raccourci pour @git
branch <nombranche>@ suivi par un @git checkout <nombranche>@.

p. Noter que la commande git status renvoie que vous êtes sur la branche
'saluer'.

h2. Changements pour Saluer: ajouter une classe Faireunsalut.

File: lib/faireunsalut.rb
class Faireunsalut
  def initialize(who)
    @who = who
  end
  def saluer
    "Bonjour, #{@who}"
  end
end
EOF

Execute:
git add lib/faireunsalut.rb
git commit -m "Ajout de la classe Faireunsalut"

h2. Changements pour Saluer: modifier le programme principal

p. Mettre à jour le fichier bonjour.rb pour utiliser saluer

File: lib/bonjour.rb
require 'faireunsalut'

# L'argument par défaut est Monde
nom = ARGV.first || "Monde"

faireunsalut = Faireunsalut.new(nom)
puts faireunsalut.saluer
EOF

Execute:
git add lib/bonjour.rb
git commit -m "bonjour utilise Faireunsalut"

h2. Changements pour Saluer: mettre à jour le Rakefile

p. Mettre à jour le Rakefile pour utiliser un processus ruby externe

File: Rakefile
#!/usr/bin/ruby -wKU

task :default => :run

task :run do
  ruby '-Ilib', 'lib/bonjour.rb'
end
EOF

Execute:
git add Rakefile
git commit -m "Rakefile mis à jour"

h2. Après

p. Nous avons maintenant une nouvelle branche appelée *saluer* avec 3 nouveaux commits dedans.
Ensuite, nous allons apprendre comment naviguer et changer de branches.

----------------------------------------------------------------------
h1. Naviguer dans les branches

h3. Buts

* Apprendre comment naviguer entre les branches d'un dépôt

p. Vous avez maintenant deux branches dans votre projet:

Execute:
git hist --all
=log

Output:
=log
EOF

h2. Passer dans la branche Master

p. Utiliser juste la commande @git checkout@ pour basculer entre les branches.

Execute:
git checkout master
=checkout
cat lib/bonjour.rb
=cat

Output:
=checkout
=cat
EOF

p. Vous êtes maintenant dans la branche master. Vous pouvez dire ceci car le
fichier bonjour.rb n'utilise pas la classe @Faireunsalut@.

h2. Retourner à nouveau dans la branche Saluer.

Execute:
git checkout saluer
=checkout2
cat lib/bonjour.rb
=cat2

Output:
=checkout2
=cat2
EOF

p. Le contenu de @lib/bonjour.rb@ confirme que nous sommes revenus dans la
branche *saluer*.

----------------------------------------------------------------------
h1. Changements dans Master

h3. Buts

* Apprendre comment gérer plusieurs branches avec différents changements (qui
sont potentiellement conflictuels).

p. Pendant que vous changiez la branche saluer, quelqu'un d'autre a décidé de
mettre à jour la branche master. Il a ajouté un fichier LISEZMOI.

h2. Basculer dans la branche master.

Execute:
git checkout master

h2. Créer le LISEZMOI.

File: LISEZMOI
C'est un exemple de Bonjour Monde pour le tutoriel git.
EOF

h2. Commiter le LISEZMOI dans master.

Execute:
git add LISEZMOI
git commit -m "Ajout d'un LISEZMOI"

----------------------------------------------------------------------
h1. Visualiser les branches qui divergent

h3. Buts

* Apprendre comment voir les divergences entre branches dans un dépôt.

h2. Voir les branches courantes

p. Nous avons maintenant deux branches divergentes dans le dépôt. Utiliser la
commande de log suivante pour voir les branches et la manière dont elles
divergent.

Execute:
git hist --all
=log

Output:
=log
EOF

p. Voici notre première chance de voir l'option @--graph@ de @git hist@ en
action. L'ajout de l'option @--graph@ à @git log@ lui permet de dessiner
l'arbre de commit en utilisant de simples caractères ASCII. Nous pouvons voir
les deux branches (saluer et master), et que la branche master est le HEAD
courant. L'ancêtre commun des deux branches est la branche "Ajout d'un Rakefile".

p. L'option @--all@ nous permet de nous assurer que nous voyons toutes les
branches. Le fonctionnement par défaut est de montrer seulement la branche
courante.

----------------------------------------------------------------------
h1. Fusion

h3. Buts

* Apprendre comment fusionner deux branches divergentes pour récupérer les
changements dans une seule branche.

h2. Fusionner les branches

p. La fusion récupère les changements dans les deux branches ensemble. Revenons
dans la branche saluer et fusionnons master dans saluer.

Execute:
git checkout saluer
=checkout
git merge master
=merge
git hist --all
=hist

Output:
=checkout
=merge
=hist
EOF

p. En fusionnant master dans notre branche saluer périodiquement, vous pouvez
récupérer n'importe quels changements dans master et garder vos changements
dans saluer pour être compatible avec ceux dans la branche principale.

p. However, Cela produit des graphes de commit très "moche". plus tard, nous
verrons les options pour faire un changement de base (rebase) plutôt qu'une
fusion (merge).

h2. Et après

p. Mais en premier, que se passe-t-il si les changements dans master rentrent
en conflit avec ceux effectués dans saluer?

----------------------------------------------------------------------
h1. Création d'un conflit

h3. Buts

* Créer un changement conflictuel dans la branche master.

h2. Rebasculer sur master et créer un conflit

p. Revenir à la branche master et faire ce changement:

Execute:
git checkout master

File: lib/bonjour.rb
puts "Quelle est votre nom?"
mon_nom = gets.strip

puts "Bonjour, #{mon_nom}!"
EOF

Execute:
git add lib/bonjour.rb
git commit -m "Rendre interactif"

h2. Voir les branches

Execute:
git hist --all
=log

Output:
=log
EOF

p. La branche master au commit "Ajout d'un LISEZMOI" a été fusionnée dans la
branche saluer, mais il y a maintenant un commit additionnel sur master qui
n'a pas été fusionné dans saluer.

h2. Et après

p. Les derniers changements dans master rentrent en conflit avec quelques
changements existants dans saluer. Après, nous allons résoudre ces changements.

----------------------------------------------------------------------
h1. Résolution des conflits

h3. Buts

* Apprendre comment gérer les conflits pendant une fusion (merge)

h2. Fusionner master dans saluer

p. Maintenant, retournons dans la branche saluer et essayons de fusionner master.

Execute:
git checkout saluer
!git merge master

Output:
$ git checkout saluer
Switched to branch 'saluer'
$ git merge master
Auto-merging lib/bonjour.rb
CONFLICT (content): Merge conflict in lib/bonjour.rb
Automatic merge failed; fix conflicts and then commit the result.
EOF

Si vous ouvrez lib/bonjour.rb, vous allez voir:

file: lib/bonjour.rb
<<<<<<< HEAD
require 'faireunsalut'

# L'argument par défaut est Monde
name = ARGV.first || "Monde"

faireunsalut = Faireunsalut.new(name)
puts faireunsalut.saluer
=======
# L'argument par défaut est Monde

puts "Quelle est votre nom?"
mon_nom = gets.strip

puts "Bonjour, #{mon_nom}!"
>>>>>>> master
EOF

p. La première section est la version dans le head de la branche courante
(saluer). La deuxième section est la version dans la branche master.

h2. Corriger le conflit

p. Vous devez manuellement résoudre le conflit. Modifier @lib/bonjour.rb@
pour être comme suivant.

File: lib/bonjour.rb
require 'faireunsalut'

puts "Quelle est votre nom?"
mon_nom = gets.strip

faireunsalut = Faireunsalut.new(mon_nom)
puts faireunsalut.saluer
EOF

h2. Commiter la résolution du conflit

Execute:
git add lib/bonjour.rb
=add
git commit -m "La fusion depuis master corrige le conflit"
=commit

Output:
=add
=commit
EOF

h2. Fusion avancée

p. Git ne propose aucun outil graphique de fusion, mais il fonctionnera très
bien avec n'importe quel outil tiers de fusion que vous souhaiteriez utiliser.
Voir "http://onestepback.org/index.cgi/Tech/Git/UsingP4MergeWithGit.red":http://onestepback.org/index.cgi/Tech/Git/UsingP4MergeWithGit.red
pour une description de l'utilisation de l'outil de fusion Perforce avec git.

----------------------------------------------------------------------
h1. Rebase VS Fusion (merge)

h3. Buts

* Apprendre la différence entre rebaser et fusionner.

h3. Discussion

p. Explorons les différences entre fusion et rebase. Pour faire
ceci, nous devons "rembobiner" le dépôt dans le temps avant de faire
le premier merge, et ensuite refaire les mêmes étapes, mais en utilisant
le rebase plutôt que la fusion.

p. Nous allons utiliser la commande @reset@ pour "rembobiner" les branches
dans le temps.

----------------------------------------------------------------------
h1. Réinitialiser la branche Saluer

h3. Buts

* Réinitialiser la branche saluer au point vant la première fusion.

h2. Réinitialiser la branche saluer

p. Revenons dans le temps sur la branche saluer à la phase _avant_ que nous
fusionnons master dedans. Nous pouvons *réintialiser* une branche à n'importe
quel commit souhaité. Essentiellement, c'est une modification du pointeur de
la branche pour qu'il pointe n'importe où dans l'arbre de commit.

p. Dans ce cas, nous voulons remettre saluer au point avant le merge avec
master. Nous devons trouver le dernier commit avant la fusion.

Execute:
git checkout saluer
=checkout
git hist
=log

Output:
=checkout
=log
EOF

p. C'est un peu dur à lire, mais en regardant dans les données, nous voyons que
le commit "Rakefile mis à jour" était le dernier commit sur la branche saluer
avant la fusion. Réinitialisons la branche saluer à ce commit.

Set: hash=hash_for("Rakefile mis à jour")
Execute:
git reset --hard <hash>
=reset

Output:
=reset
EOF

h2. Vérifier la branche.

p. Regardez dans le log de la branche saluer. Nous n'avons plus les commits de
fusion dans l'historique.

Execute:
git hist --all
=log2

Output:
=log2
EOF

----------------------------------------------------------------------
h1. Réinitialiser la branche Master

h3. Buts

* Réinitialiser la branche master au point avant le commit conflictuel.

h2. Réinitialiser la branche master

p. Quand nous avons ajouté le mode interactif dans la branche master, nous
avons fait un changement qui rentre en conflit avec les changements dans la
branche saluer. "Rembobinons" la branche master au point avantle changement
conflictuel. Cela va nous permettre de faire une démonstration de la commande
rebase sans s'inquiéter des conflits.

Execute:
git checkout master
git hist
=log

Output:
=log
EOF

p. Le commit 'Ajout d'un LISEZMOI' est celui qui est directement avant le mode
interactif conflictuel. Nous allons réinitialiser la branche master au commit
'Ajout d'un LISEZMOI'.

Set: hash=hash_for("Ajout d'un LISEZMOI")
Execute:
git reset --hard <hash>
git hist --all
=log2

p. Examiner le log. Cela devrait ressembler comme si on avait rembobiné
le dépôt dans le temps au point avant la fusion de quoi que ce soit.

Output:
=log2
EOF

----------------------------------------------------------------------
h1. Rebaser

h3. Buts

* Utiliser la commande rebase plutôt que la commande merge.

p. Ok, nous sommes maintenant revenu dans le temps avant la première fusion et
nous voulons obtenir les changements de master dans notre branche saluer.

p. Cette fois nous allons utiliser la commande rebase à la place de la commande
merge pour apporter les changements depuis la branche master.

Execute:
git checkout saluer
git rebase master
git hist
=log

Output:
$ go saluer
Switched to branch 'saluer'
$
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: Ajout de la classe Faireunsalut
Applying: bonjour utilise Faireunsalut
Applying: Rakefile mis à jour
$
=log
EOF

h2. Merge VS Rebase

p. Le résultat final de rebase est très similaire à celui de merge. La branche
saluer contient maintenant tous ses changements, aussi bien que tous ceux de la
branche master. Cependant, l'arbre de commit est assez différent. L'arbre de
commit pour la branche saluer a été réécrit de manière à ce que la branche
master soit une partie de l'historique de commit. Cela laisse une chaîne de
commit linéaire et beaucoup plus facile à lire.

h2. Quand faire un Rebase, quand faire un Merge?

p. Ne pas utiliser rebase quand ...

# Si la branche est publique et partagée avec d'autres. Réécrire publiquement des
branches partagées risque surtout "d'emmerder" les autres membres de votre équipe.
# Quand l'historique _exacte_ de votre branche de commit est importante (étant
donné que rebase réécrit l'historique de commit).

p. En suivant les règles ci-dessus, je tend à utiliser rebase pour des branches
locales à usage court et merge pour les branches partagées dans le dépôt public

----------------------------------------------------------------------
h1. Fusionner dans la branche master

h3. Buts

* Nous avons gardé notre branche saluer à jour avec master (via rebase),
maintenant, il est temps de fusionner les changements de saluer dans la
branche master.

h2. Fusionner saluer dans master

Execute:
git checkout master
git merge saluer
=merge

Output:
$ git checkout master
Switched to branch 'master'
$
=merge
EOF

p. Comme le head de master est une ancêtre direct du head de la branche
saluer, git est capable de faire un merge en "avance rapide". Quand
on fait l'avance rapide, le pointeur de la branche est simplement déplacé en
avant pour pointer vers le même commit que pour la branche faireunsalut.

p. Il n'y aura jamais de conflits dans un merge en "avance rapide".

h2. Examiner les logs

Execute:
git hist
=log

Output:
=log
EOF

p. Les branches saluer et master sont maintenant identiques.

----------------------------------------------------------------------
h1. Dépôts multiples

p. Jusqu'à maintenant nous avons travaillé avec un seul dépôt git.
Cependant, git excelle dans le travail avec plusieurs dépôts. Ces dépôts
supplémentaires peuvent être stockés localement, ou peuvent être récupérés
à travers une connexion réseau.

p. Dans la section suivante, nous allons créer une nouveau dépôt appelé
"clone_de_bonjour". Nous allons vous montrer comment déplacer des changements
d'un dépôt à un autre, et comment gérer les conflits qui se posent entre
deux dépôts.

 !git_clone.png!


p. Pour le moment, nous allons travailler avec des dépôts locaux
(c'est à dire des dépôts stockés sur votre disque dur local), cependant
la plupart des choses apprises dans cette section s'appliquera à de
multiples dépôts qu'ils soient locaux ou disponibles via un réseau.

p. *NOTE:* Nous allons faire des changements à des copies de nos dépôts.
Assurez vous de faire attention dans quel dépôt vous êtes à chaque étape
pour chaque partie du tutoriel.

----------------------------------------------------------------------
h1. Cloner des dépôts

h3. Buts

* Apprendre comment faire des copies des dépôts.

h2. Aller au répertoire de travail

p. Aller au répertoire de travail et faire un clone de votre dépôt bonjour.

Execute:
cd ..
=cd
pwd
=pwd
ls
=ls

p{color:red}. *NOTE: Maintenant dans le répertoire de travail.*

Output:
=cd
=pwd
=ls
EOF

p. A ce stade vous devriez être dans le répertoire "work". Il devrait
avoir un seul dépôt ici nommé "bonjour".

h2. Créer un clone du dépôt bonjour

p. Faisons un clone du dépôt.

Execute:
git clone bonjour clone_de_bonjour
=clone
ls
=ls2
+cd clone_de_bonjour
+git config user.name "Jim Weirich"
+git config user.email "jim (at) edgecase.com"
+cd ..

Output:
=clone
=ls2
EOF

p. Il devrait maintenant y avoir deux dépôts dans votre répertoire de
travail: le dépôt original "bonjour" et le nouveau dépôt cloné "clone_de_bonjour".

----------------------------------------------------------------------
h1. Examiner le dépôt cloné

h3. Buts

* Apprendre à propos des branches sur les dépôts distants.

h2. Jetons un oeil au dépôt cloné

p. Regardons un peu le dépôt cloné.

Execute:
cd clone_de_bonjour
=cd
ls
=ls

Output:
=cd
=ls
EOF

p. Vous devriez voir une liste de tous les fichiers au niveau supérieur de votre
dépôt original (@LISEZMOI@, @Rakefile@ et @lib@).


h2. Examiner l'historique du dépôt

Execute:
git hist --all
=log

Output:
=log
EOF

p. Vous devriez maintenant voir une liste de tous les commits dans le
nouveau dépôt, et il devrait (plus ou moins) correspondre à l'historique
commits dans le dépôt original. La seule différence devrait être dans le
nom des branches.

h2. Branches distantes

p. Vous devriez voir une branche *master* (avec *HEAD*) dans la liste
d'historique. Mais vous allez voir aussi nombres de branches nommées
étrangement (*origin/master*, *origin/saluer* et *origin/HEAD*). Nous
allons les voir sous peu.

----------------------------------------------------------------------
h1. Qu'est ce qu'origin?

h3. Buts

* Apprendre à propos du nommage des dépôts distants.

Execute:
git remote
=remote

Output:
=remote
EOF

p. Nous voyons que le dépôt cloné connait un dépôt distant nommé origin.
Voyons ce que si nous pouvons avoir plus d'informations sur origin:

Execute:
git remote show origin
=show

Output:
=show
EOF

p. Maintenant, nous voyons que le dépôt distant "origin"est simplement le
dépôt original *bonjour*. Les dépôts distants vivent typiquement sur une
machine séparée, de manière possible aussi sur une serveur centralisé.
Comme nous le voyons ici, cependant, ils peuvent aussi pointer vers un
répertoire sur la même machine.
Il n'y a rien de particulier à propos du nom "origin", cependant la
convention est d'utiliser le nom "origin" pour le nom du dépôt centralisé
primaire (s'il y en a un).

----------------------------------------------------------------------
h1. Branches distantes

h3. Buts

* Apprendre les différences entre branches locales VS branches distantes

p. Regardons dans les branches disponibles dans notre dépôt cloné.

Execute:
git branch
=branch

Output:
=branch
EOF

p. C'est ça, seule la  branche master est listée. Où est la branche saluer
? La commande *git* *branch* liste seulement les branches locales par
défaut.

h2. Lister les branches distantes

p. Essayer ceci pour voir toutes les branches:

Execute:
git branch -a
=branch_a

Output:
=branch_a
EOF

p. Git a tous les commits du dépôt original, mais les branches
dans le dépôt distant ne sont pas traitées comme des branches locales ici.
Si nous voulons notre propre branche *saluer*, nous devons la créer nous-même.
Nous allons voir comment faire cela dans une minute.

----------------------------------------------------------------------
h1. Changer le dépôt original

h3. Buts

* Faire quelques changements au dépôt original afin que nous puissions
récupérer les changements

h2. Faire un changement dans le dépôt original *bonjour*

Execute:
cd ../bonjour
+pwd
# (Vous devriez maintenant être dans le dépôt original bonjour maintenant)

p{color:red}. *NOTE: Maintanant dans le dépôt _bonjour_*

p. Faire les changements suivants à LISEZMOI:

File: LISEZMOI
C'est un exemple de Bonjour Monde pour le tutoriel git.
(Changé dans l'original)
EOF

p. Maintenant ajouter et commiter ce changement

Execute:
git add LISEZMOI
git commit -m "Changement de LISEZMOI dans le dépôt original"

h2. Après

p. Le dépôt original maintenant a des changements tardifs qui ne sont
pas dans la version clonée. Ensuite, nous allons récupérer ces changements
dans le dépôt cloné.

----------------------------------------------------------------------
h1. Rapporter (fetch) les changements

h3. Buts

* Apprendre comment rapporter les changements depuis un dépôt distant.

Execute:
cd ../clone_de_bonjour
+pwd
git fetch
=fetch
git hist --all
=hist

p{color:red}. *NOTE: Maintenant dans le dépôt _clone_de_bonjour_*

Output:
=fetch
=hist
EOF

p. Actuellement le dépôt a tous les commits provenant de celui
original, mais ils ne sont pas intégrés dans les branches locales
du dépôt cloné.

p. Trouver le commit "Changement de LISEZMOI dans le dépôt original" dans
l'historique ci-dessus. Notez que le commit inclut "origin/master" et "origin/HEAD".

p. Maintenant regardez dans le commit "Updated Rakefile". Vous allez voir
que sa branche locale master pointe vers ce commit, pas vers le nouveau commit
que nous venons juste de rapporter.

p. Le résultat de ceci est que la commande "git fetch" va maintenant rapporter
les nouveaux commits du dépôt distant, mais qu'elle ne va pas fusionner ces
commits dans les branches locales.

h2. Vérifier le fichier LISEZMOI

Nous pouvons démontrer que le LISEZMOI cloné est inchangé.

Execute:
cat LISEZMOI

Output:
$ cat LISEZMOI
C'est un exemple de Bonjour Monde pour le tutoriel git.
EOF

p. Voyez, pas de changements.

----------------------------------------------------------------------
h1. Fusionner les changements récupérés

h3. Buts

* Apprendre comment récupérer les changements récupérés dans la branche
courante et dans le répertoire de travail.

h2. Fusionner les changements récupérés dans la branche master locale

Execute:
git merge origin/master
=merge

Output:
=merge
EOF

h2. Vérfier le fichier LISEZMOI à nouveau

p. Nous devrions voir les changements maintenant.

Execute:
cat LISEZMOI

Output:
$ cat LISEZMOI
C'est un exemple de Bonjour Monde pour le tutoriel git.
(Changé dans l'original)
EOF

p. Il y a les changements. Même si "git fetch" ne fusionne pas les
changements, nous pouvons toujours manuellement les fusionner depuis
le dépôt distant.

h2. Ensuite

p. Après regardons comme combiner le processus fetch et merge dans
une seule commande.

----------------------------------------------------------------------
h1. "Tirer" (pull) les changements

h3. Buts

* Apprendre que @git pull@ est équivalent à un @git fetch@ suivi par un @git merge@.

h3. Discussion

p. Nous n'allons pas repasser tout le processus de création d'un autre
changement et le récupérer encore, mais nous voulons que vous sachiez
que faire:

pre(instructions). git pull

est en fait équivalent à ces deux étapes:

pre(instructions). git fetch
git merge origin/master

----------------------------------------------------------------------
h1. Ajouter une branche pour le suivi

h3. Buts

* Apprendre comment ajouter une branche locale qui suit une branche distante.

p. Les branches qui commencent avec remotes/origin sont les branches
du dépôt original. Notez que nous n'avons plus une branche appelée saluer,
mais git sait que le dépôt original has une branche saluer.

h2. Ajouter une branche locale qui permet de suivre une branche distante.

Execute:
git branch --track saluer origin/saluer
=branch_track
git branch -a
=branch_a
git hist --max-count=2
=log

Output:
=branch_track
=branch_a
=log
EOF

p. Nous pouvons maintenant voir que la branche saluer dans la liste des
branches et dans le log.

----------------------------------------------------------------------
h1. Dépôts dit "nus" (bare)

h3. Buts

* Apprendre comment créer des dépôts dit "nus" (bare).

p. Les dépôts dit "nus" (sans répertoires de travail) sont généralement
utilisés pour être partagés.

h2. Créer un dépôt "nu".

Execute:
cd ..
+pwd
git clone --bare bonjour bonjour.git
=clone
ls bonjour.git
=ls

p{color:red}. *NOTE: Maintenant dans le répertoire de travail*

Output:
=clone
=ls
EOF

p. La convention est que les dépôts finissant avec '.git' sont des
dépôts "nus". Nous pouvons voir qu'il n'y a pas de répertoire de travail
dans le dépôt bonjour.git. C'est essentiellement rien de plus que le
répertoire .git d'un dépôt non "nu".

----------------------------------------------------------------------
h1. Ajouter un dépôt distant

h3. Buts

* Ajouter le dépôt dit "nu" (bare) comme distant par rapport à notre
dépôt d'origine.

p. Ajoutons le dépôt bonjour.git à notre dépôt d'origine.

Execute:
cd bonjour
+pwd
git remote add partager ../bonjour.git

p{color:red}. *NOTE: Maintenant dans le dépôt +bonjour+.*

----------------------------------------------------------------------
h1. Envoyer un changement

h3. Buts

* Apprendre comment envoyer un changement vers un dépôt distant.

p. Comme les dépôts dit "nus" sont habituellement partagé sur une sorte
de serveur réseau, il est difficile de se rendre dans le dépôt et de récupérer.
les changements. Ainsi nous avons besoins d'envoyer nos changements dans les
autres dépôts.

p. Commençons par créer un changement à envoyer. Editer le fichier LISEZMOI
et le commiter

File: LISEZMOI
C'est un exemple de Bonjour Monde pour le tutoriel git.
(Changé dans l'original et envoyé dans partager)
EOF

Execute:
git checkout master
git add LISEZMOI
git commit -m "Ajout du commentaire partagé à lisezmoi"

p. Maintenant envoyer le changement à notre dépôt partagé.

Execute:
git push partager master
=push

p. _partager_ est le nom du dépôt qui reçoit les changements que nous
envoyons. (Souvenez vous, nous l'avons ajouté comme distant dans la
précédente partie du tutoriel.)

Output:
=push
EOF

p(note). *NOTE:* Nous devons explicitement nommé la branche master qui
devra recevoir l'envoi. Il est possible de le configurer automatiquement,
mais je ne me souviens _jamais_ des commandes pour le faire.
Regarder le fichier gem "Git Remote Branch" pour une gestion facile
des branches distantes.

----------------------------------------------------------------------
h1. Récupérer les changements partagés

h3. Buts

* Apprendre comment récupérer les changements depuis un dépôt partagé.

p. Aller rapidement dans le clône du dépôt et maintenant récupérons rapidement
les changements qu'on vient juste d'effectuer sur le dépôt partagé.

Execute:
cd ../clone_de_bonjour
+pwd

p{color:red}. *NOTE: Maintenant dans le dépôt _clone_de_bonjour_.*

p. Continuer avec ...

Execute:
git remote add partager ../bonjour.git
git branch --track partager master
git pull partager master
cat LISEZMOI

----------------------------------------------------------------------
h1. Héberger vos dépôts Git

h3. Buts

* Apprendre comment configurer un serveur git pour partager des dépôts.

p. Il y a de nombreux moyens de partager des dépôts git via un réseau.
Voici une méthode rapide et pas "très propre".

h2. Démarrer le serveur git

execute:
# (Depuis le répertoire de travail)
git daemon --verbose --export-all --base-path=.

p. Maintenant, dans une fenêtre de terminal séparée, aller au répertoire de travail

execute:
# (From the work directory)
git clone git://localhost/bonjour.git network_bonjour
cd network_bonjour
ls

p. Vous devriez voir une copie du projet bonjour.

h2. Envoyer vers le démon Git

p. Si vous voulez pouvoir pousser vers le dépôt du démon git, ajouter
@--enable=receive-pack@ à la commande du démon git. Faites attention parce
qu'il n'y a pas d'authentification sur le serveur, n'importe qui peut
pousser vers votre dépôt.

----------------------------------------------------------------------
h1. Partager des dépôts

h3. Buts

* Apprendre comment partager un dépôt via le WIFI.

p. Voir si votre voisin fait tourner une "démon" git. Echanger les
addresses IP et voir si vous pouvez récupérer chacun le dépôt de l'autre.

p(note). *NOTE:* Le gem gitjour est très pratique pour partager
des dépôts ad-hoc.

----------------------------------------------------------------------
h1. Sujets avancés / futurs

p. Voici quelques un des sujets que vous pourriez souhaiter regarder
par vous même:

* Annulation des changements commités
* Fin de lignes pour les différents systèmes d'exploitation
* Serveurs distants
* Protocoles
* Paramétrage SSH
* Gestion de branche à distance
* Recherche des commits buggés (git bisect)
* Chaînes de traitement
* Outils graphiques (gitx, gitk, magit)
* Usage avec GitHub

----------------------------------------------------------------------
h1. Merci

p. Merci d'avoir essayé le tutoriel Git Immersion. Libre à vous de prendre
contact avec l'auteur original (anglophone) à l'adresse jim.weirich@gmail.com
ou pour des remarques sur la traduction à thomas_gratier@yahoo.fr

